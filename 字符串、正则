字符串截取及切割
子串截取的三种用法：
${var:起始位置:长度}
使用${}方式截取字符串时，起始位置是从0开始的（和数组下标编号类似）
expr substr "$var" 起始位置 长度
echo $var | cut -b 起始位置-结束位置
路径分割：
取目录位置：dirname "字符串"
取文档的基本名称：basename "字符串"
子串替换的两种用法：
只替换第一个匹配结果：${var/old/new}
替换全部匹配结果：${var//old/new}
字符串掐头去尾：
从左向右，最短匹配删除：${变量名#*关键词}
从左向右，最长匹配删除：${变量名##*关键词}
从右向左，最短匹配删除：${变量名%关键词*}
从右向左，最长匹配删除：${变量名%%关键词*}

批量修改当前目录下的文件扩展名，将.doc改为.txt。
脚本内容参考如下：
[root@svr5 ~]# vim renfile.sh
#!/bin/bash
for FILE in *.doc                 （.doc可以换成任何变量，可以用变量表示）
do
    mv $FILE  ${FILE%.doc}.txt     （.txt同上）
done
#########################################################################################################
字符串初值的处理
只取值，${var:-word}
若变量var已存在且非Null，则返回 $var 的值；否则返回字串“word”，原变量var的值不受影响。
[root@svr5 ~]# echo ${XX:-Tarena}      //因XX已存在，输出变量XX的值
[root@svr5 ~]# echo ${YY:-Tarena}      //因YY不存在，输出“Tarena”
[root@svr5 ~]# cat /root/test.sh
#!/bin/bash
read  -p   "请输入用户名:"   user
read  -p   "请输入用户名:"   pass
[ -z $user ] && exit                    //如果无用户名，则脚本退出
pass=${pass:-123456}                    //如果用户没有输入密码，则默认密码为123456
useradd  $user
echo "$pass"  | passwd   --stdin   $pass

用来从键盘读入一个正整数x，求从1到x的和；当用户未输入值（直接回车）时，为了避免执行出错，应为x赋初值1 。
[root@svr5 ~]# vim sumx.sh
#!/bin/bash
read -p "请输入一个正整数：" x
x=${x:-1}
i=1; SUM=0
while [ $i -le $x ]
do
    let SUM+=i
    let i++
done
echo "从1到$x的总和是：$SUM"
#########################################################################################################
expect预期交互
常见的expect指令：
定义环境变量：set 变量名 变量值
创建交互式进程：spawn 交互式命令行
触发预期交互：expect "预期会出现的文本关键词:" { send "发送的文本\r" }
在spawn建立的进程中允许交互指令：interact
[root@svr5 ~]# yum  -y  install  expect                  //安装expect

实现免交互登录
[root@svr5 ~]# vim  expect_ssh.sh 
#!/bin/bash
host=192.168.4.5
expect << EOF
spawn ssh root@$host                                #//创建交互式进程
expect "(yes/no)?" { send "yes\r" }
expect "password:" { send "123456\r" }              #//自动发送密码
expect "#   { send "pwd > /tmp/$user.txt \r" }      #//发送命令
expect "#"  { send "exit\r" }
EOF
##############################################################################################################
正则表达式
                                        基本正则符号              描述
                                        ^                   匹配行首
                                        $                   匹配行尾
                                        []                  集合,匹配集合中的任意单个字符
                                        [^]                 对集合取反
                                        .                   匹配任意单个字符
                                        *                   匹配前个字符任意次数
                                        \{n,m\}             匹配前个字符N到M次
                                        \{n\}               匹配前个字符N次
                                        \{n,\}              匹配前个字符N次以上
                                        \(\)                保留
                                        
                                        扩展正则                描述
                                        +                   最少匹配一次
                                        ?                   最多匹配一次
                                        {n,m}               匹配N到M次
                                        ()                  结合为整体,保留
                                        |                   或者
                                        \b                  单词边界
3）匹配邮箱地址
电子邮箱地址的特征是“用户名@域名”，主要包括：
用户名与域名之间以 @ 分隔
用户名不少于3个字符，可能由字母、下划线、句点 . 、数字组成
域名应至少有一个 . 分隔，分隔的各部分至少2个字符，可能由字母、减号、数字组成
根据上述特点，编写的正则表达式参考如下：其中域名分隔以“\.”表示，不能表示为 . ，否则会匹配任意单个字符。
[root@svr5 ~]# [0-9a-zA-Z_.]{3,}@[0-9a-zA-Z.-]{2,}(\.[0-9a-zA-Z-]{2,})+
匹配主机名
由 . 分隔，至少包括3组字符串
每组字符串不少于2个字符，可能由字母、减号、数字、下划线组成
主机名后必须是单词边界，主机名前不能有@符号
[root@svr5 ~]# egrep '^[^@][0-9a-zA-Z_-]{2,}(\.[0-9a-zA-Z_-]{2,}){2,}\>' \
匹配IP地址
归纳合法IP地址的特点：
以 . 分隔，一共由四组十进制数构成
每组数值的范围为0-255，字符宽度为1-3位
前后必须是单词边界
过滤出ifconfig命令输出结果中包含IP地址的行为
[root@svr5 ~]# ifconfig | egrep '\<[0-9]{1,3}(\.[0-9]{1,3}){3}\>'

